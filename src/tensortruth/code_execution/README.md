# Code Execution Module

Automatic Python code execution for Tensor Truth RAG chat system with Docker-based sandboxing.

## Overview

This module enables automatic execution of Python code blocks generated by the LLM in isolated Docker containers. Each chat session gets its own persistent container, allowing variables and state to persist across multiple code executions (similar to Jupyter notebooks).

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Detection Layer                          │
│  Parses Python code blocks from streaming LLM responses     │
│         (CodeBlockParser)                                   │
└────────────────┬────────────────────────────────────────────┘
                 │ List[CodeBlock]
                 ▼
┌─────────────────────────────────────────────────────────────┐
│                   Execution Layer                           │
│  SessionContainerManager: Maps session_id → Docker container│
│  ExecutionOrchestrator: Runs code with timeout/limits       │
└────────────────┬────────────────────────────────────────────┘
                 │ ExecutionResult
                 ▼
┌─────────────────────────────────────────────────────────────┐
│                    Display Layer                            │
│  Renders execution results with expandable output           │
│         (rendering.py)                                      │
└─────────────────────────────────────────────────────────────┘
```

## Components

### `parser.py` - Code Block Detection
- **CodeBlockParser**: Incrementally parses markdown code blocks from streaming tokens
- State machine-based parsing (handles incomplete blocks during streaming)
- Only detects Python code blocks (`python`, `py`, `python3`, `py3`)

### `container_manager.py` - Docker Lifecycle Management
- **SessionContainerManager**: Manages Docker containers per chat session
- Creates isolated containers with:
  - No network access (`network_mode="none"`)
  - Resource limits (512MB RAM, 50% CPU, 100 max processes)
  - Non-root user execution
  - Persistent workspace volume
- Automatic cleanup (1 hour idle timeout, immediate on session delete)

### `executor.py` - High-Level Orchestration
- **ExecutionOrchestrator**: Coordinates validation, execution, and logging
- **ExecutionResult**: Dataclass with execution status, stdout, stderr, timing

### `validator.py` - Pre-Execution Safety
- **CodeValidator**: AST-based validation for dangerous operations
- Detects: dangerous imports (os, subprocess, etc.), eval/exec calls, input() blocking
- Returns warnings (doesn't block execution - container is already isolated)

### `audit_logger.py` - Security Audit Trail
- **AuditLogger**: Logs all executions to JSONL file
- Stored at: `~/.tensortruth/execution_audit.jsonl`
- Includes: timestamp, session_id, code hash, full code, results

### `executor.Dockerfile` - Container Image
- Base: Python 3.11-slim
- Pre-installed packages: numpy, pandas, matplotlib, seaborn, scipy, scikit-learn, requests, pillow
- Non-root user: `coderunner`
- Workspace: `/workspace` (mounted from host)

## Usage

### Basic Execution

```python
from tensortruth.code_execution import ExecutionOrchestrator, CodeBlock

orchestrator = ExecutionOrchestrator()

code_blocks = [
    CodeBlock(language="python", code="x = 42\nprint(x)", start_position=0)
]

results = orchestrator.execute_blocks(
    session_id="abc123",
    code_blocks=code_blocks,
    timeout=30
)

for result in results:
    if result.success:
        print(result.stdout)  # "42"
    else:
        print(result.error_message)
```

### Slash Commands

Users can control execution via chat commands:

- `/exec status` - Show execution status and Docker availability
- `/exec on` - Enable automatic code execution
- `/exec off` - Disable automatic code execution
- `/exec reset` - Restart container (clears all state)

### Session State Initialization

Set default state in Streamlit:

```python
if "code_execution_enabled" not in st.session_state:
    st.session_state.code_execution_enabled = True

if "code_exec_timeout" not in st.session_state:
    st.session_state.code_exec_timeout = 30
```

## Security

### Multi-Layer Isolation

1. **Container Isolation**:
   - Network disabled (no internet access)
   - Resource limits prevent DoS
   - Non-root user
   - Read-only root filesystem (except `/workspace`)

2. **Pre-Execution Validation**:
   - AST parsing for dangerous patterns
   - Warns about system calls, network access, blocking operations
   - Detects syntax errors before execution

3. **Audit Logging**:
   - All executions logged with code hash
   - JSONL format for easy analysis
   - Includes execution status and timing

4. **Timeout Enforcement**:
   - Configurable timeout (default 30s)
   - Hard kill on timeout
   - Container auto-restarts on crash

### Limitations

- **Not 100% secure**: Docker provides good isolation but is not a security boundary
- **Trust your LLM**: If the LLM is compromised, it could generate malicious code
- **Local use only**: Designed for single-user local deployment

## Persistence

### Session Workspace

Each session gets a workspace directory:
```
~/.tensortruth/sessions/{session_id}/workspace/
```

Files created by code persist across executions:
```python
# First execution
with open("data.txt", "w") as f:
    f.write("hello")

# Later execution (same session)
with open("data.txt", "r") as f:
    print(f.read())  # "hello"
```

### Variable State

Variables persist using `exec(code, globals())` in the container:
```python
# First execution
x = 42

# Later execution
print(x)  # 42
```

**Important**: Variables are lost if the container restarts (crashes, timeout, manual reset).

## Error Handling

### Docker Not Available

If Docker daemon is not running:
```python
orchestrator = ExecutionOrchestrator()
if not orchestrator.is_docker_available():
    # Fallback: Display code blocks without execution
    st.warning("Docker not available - code execution disabled")
```

### Execution Failures

```python
result = orchestrator.execute_blocks(session_id, code_blocks)[0]

if not result.success:
    print(f"Error: {result.error_message}")
    print(f"stderr: {result.stderr}")
```

### Container Crashes

Containers are automatically recreated on next execution:
```python
# Container crashes mid-execution
# Next execution creates new container (state lost)
```

## Testing

### Unit Tests (No Docker)
```bash
pytest tests/test_parser.py
pytest tests/test_validator.py
```

### Integration Tests (Mocked Docker)
```bash
pytest tests/test_container_manager.py
```

### E2E Tests (Real Docker)
```bash
pytest tests/test_executor_e2e.py -m requires_docker
```

## Troubleshooting

### "Docker not available"
- Ensure Docker daemon is running: `docker ps`
- Check Docker socket permissions: `ls -l /var/run/docker.sock`

### "Failed to create container"
- Check Docker image exists: `docker images | grep tensortruth-executor`
- Build manually: `docker build -f executor.Dockerfile -t tensortruth-executor:latest .`

### "Execution timeout"
- Increase timeout: `st.session_state.code_exec_timeout = 60`
- Check for infinite loops in code

### "Variables lost between executions"
- Container may have restarted (check logs)
- Use `/exec status` to check container health

## Future Enhancements

- **Rich outputs**: IPython kernel integration for plots, dataframes
- **Streaming execution**: Real-time stdout/stderr during execution
- **Multi-language support**: R, JavaScript, Bash
- **Cloud sandboxes**: E2B integration as fallback
- **Persistent kernels**: SQLite-backed state persistence across container restarts
